               
# ==============================   ЗАВДАННЯ   ==========================================================

# Вам потрібно реалізувати функцію для виведення списку колег, яких потрібно привітати з днем народження на тижні.

# У вас є список словників users, кожен словник у ньому обов'язково має ключі name та birthday. 
# Така структура представляє модель списку користувачів з їх іменами та днями народження. 
# Де name — це рядок з ім'ям користувача, а birthday — це datetime.date об'єкт, в якому записаний день народження.

# Наприклад:

# {"name": "Bill Gates", "birthday": datetime(1955, 10, 28).date()}

# Ваше завдання написати функцію get_birthdays_per_week, яка отримує на вхід список users повертає словник користувачів, 
# яких потрібно привітати по днях на наступному тижні.

# Формат словника який повертає функція get_birthdays_per_week в нас буде наступним:

# {'Monday': ['Bill', 'Jan'], 'Wednesday': ['Kim']}

# Ключ словника це дні тижня "Monday", "Tuesday", "Wednesday", "Thursday", "Friday". 
# Значення це списки користувачів з днями народження на тиждень вперед від поточного дня, включаючи поточний день.

# ПРИМІТКА
# Для прикладу, якщо я запускаю скрипт в середу, то в ключах "Wednesday", "Thursday", "Friday" дні народження цього тижня, 
# а в ключах "Monday", "Tuesday" зберігаються дні народження наступного тижня. 
# В ключі "Monday" завжди дні народження цього тижня які припали на вихідні.

# Критерії оцінювання:
# Код повинен бути чистим і дотримуватися стандартів PEP 8.
# Функція повинна коректно обробляти всі дні тижня.
# Функція повинна коректно враховувати вихідні дні і переносити їх на понеділок.
# Функція повинна враховувати випадки, коли день народження вже минув у цьому році.
# Функція повинна коректно працювати з порожнім списком користувачів.
# Функція повинна коректно враховувати ситуації, коли всі дні народження вже минули у цьому році.
# Файл з домашнім завданням main.py має імпорт from datetime import date
# Для визначення яка сьогодні дата використовується тільки date.today()
# Тиждень починається з понеділка
# Ви повинні завантажити наступний репозиторій. Виконання домашнього завдання треба зробити в файлі main.py.
#  Змінювати назви файлів та функцій не можна.

# Щоб перевірити правильність виконання функції get_birthdays_per_week вам потрібно запустити файл check_homework.py, 
# який перевіряє п'ять основних тестових випадків, для вашої реалізації функції get_birthdays_per_week:

# Тест коли усі дні народження користувачів є у майбутньому і не впадають на вихідні.
# Тест коли дні народження деяких користувачів випадають на вихідні.
# Тест коли деякі дні народження користувачів вже минули у цьому році.
# Тест коли у списку немає користувачів.
# Тест коли всі дні народження користувачів вже минули у цьому році.
# Якщо всі тести домашнього завдання пройдені він вам сповістить це зеленим кольором в консолі.

# img

# Якщо тести не пройдено, то сповіщення для не пройденого тесту буде червоного кольору в консолі.

# img

# Після того як ваш код буде проходити всі тести ви здаєте його на перевірку ментору в LMS.

# ++++++++++++++++++++ Допоміжні куски коду для створення словників за заомчування. ++++++++++++++++++++++++++++++++++++

# # Якщо цікавить автоматичне створення, то можна зробити наступним чином, тільки коду буде більше

# from datetime import datetime, timedelta
# from collections import defaultdict

# # Визначаємо початкову дату
# start_date = datetime(2023, 1, 1)

# # Створюємо словник зі списками за замовчуванням
# template_dict = defaultdict(list)
# print(template_dict)

# # Додаємо ключі для кожного дня тижня для наступного тижня
# for i in range(7):
#     current_date = start_date + timedelta(days=i)
#     day_of_week = current_date.strftime('%A')  # Отримуємо назву дня тижня
#     template_dict[day_of_week]
#     print(template_dict)

# # Виводимо результат
# print(dict(template_dict))

# # Або використай datetime, dict comprehension
# start_date = datetime(2023, 1, 1)
# # Створюємо словник зі списками за замовчуванням за допомогою dict comprehension
# template_dict = {current_date.strftime('%A'): [] for current_date in (start_date + timedelta(days=i) for i in range(7))}

# ======================= Алгоритм  який використано для вирішення завданняя  ==========================

# Переданий в функцію список днів народжень  ми спочатку перевіримо чи порожній ( якщо порожній повертем відразу пустий словник).
# Далі за допомогою допоміжої функції *sort_birthdate(users) відсортуємо переданий список згідно вимог завдання.
# Якщо після сортування функція поверне пустий список - значить всі дні народження вже минули у цьому році.Повертаємо пустий словник.
# Якщо список буде не прожній - занчить в ньому є дні народження які потрібно поверути у відповідному форматі згідно умов завданя.
# Форматуємо наш вісортований список повернутий з *sort_birthdate(users) допоміжною функцією *format_birthdays(sort_birthdays) 
# Відсортований і відформатований список аналізуєо в тілі основної функції *get_birthdays_per_week(users)  повертаємо в форматі :
# {'Monday': ['Bill', 'Jan'], 'Wednesday': ['Kim']}

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++


from datetime import datetime, timedelta, date


WEEKEND = ['Saturday', 'Sunday'] # Список для визначення вихідних днів.


def range_from_12_26_to_01_01(): # Допоміжна функція в якій формуємо список *datetime обєктів в поточному році , в діапазоні з 12.26 по 12.31 включно.
                                 # Цей список потрібний щоб перевірити чи поточна дата припадає на період в кінці року з з 12.26 по 12.31, тоді потрібно врахувати дні народження які будуть вже в наступому році про те на цьому тижні . 
      
    start_date = datetime(year=date.today().year, month=12, day=26).date() # Перший елемент списку за замовчуванням.

    template_list = [current_date for current_date in (start_date + timedelta(days=i) for i in range(6))] # Створюємо список з обєктами *datetime за замовчуванням за допомогою list comprehension
        
    return template_list  # [datetime.date(2024, 12, 26), datetime.date(2024, 12, 27), datetime.date(2024, 12, 28), datetime.date(2024, 12, 29), datetime.date(2024, 12, 30), datetime.date(2024, 12, 31)]


def range_from_01_01_to_01_07(): # Допоміжна функція в якій формуємо список *datetime обєктів в поточному році , в діапазоні з 01.01 по 01.06 включно.
                                 # Цей список потрібний щоб перевірити чи поточна дата народження припадає на період початку року з  01.01 по 01.06, ці дні народження які були вже в цьому році, але будуть на цьому тижні .

    start_date = datetime(year=date.today().year, month=1, day=1).date() # Перший елемент списку за замовчуванням.

    template_list = [current_date for current_date in (start_date + timedelta(days=i) for i in range(6))] # Створюємо список з обєктами *datetime за замовчуванням за допомогою list comprehension
    
    return template_list # [datetime.date(2024, 1, 1), datetime.date(2024, 1, 2), datetime.date(2024, 1, 3), datetime.date(2024, 1, 4), datetime.date(2024, 1, 5), datetime.date(2024, 1, 6)]


def sort_birthdate(users): # Допоміжна функція в якій будемо, з переданого списку днів народжень, повертати ті які відповідають умовам завдання.
                           # Приймає один аргумент, список, де коже елемент є словником формату {"name": "Bill Gates", "birthday": datetime(1955, 10, 28).date()}
                           # Повертає список з таких же елементів того ж формату, але тільки тих які відповідають умовам завдання.    

    future_вirthday_list = [] # Пустий список в який будемо додавати елементи які відповідають умовам завдання .

    current_date = date.today() # Визачаємо поточну дату .# 2024-01-08 (дата запису цього коментаря 2024-01-08)

    list_data_range_from_12_26_to_01_01 = range_from_12_26_to_01_01() # Для поточної дати *list_data_range_from_12_26_to_01_01 = [datetime.date(2024, 12, 26), ..., datetime.date(2024, 12, 31)]

    list_data_range_from_01_01_to_01_07 = range_from_01_01_to_01_07() # Для поточної дати *list_data_range_from_01_01_to_01_07 = [datetime.date(2024, 1, 1), ..., datetime.date(2024, 1, 6)]
    
    for вirthday_dict in users: # Цикл в якому проходимось по елементам списку переадного в функцію.
                                # Міняємо кожному елементу занчення року на сьогоднішнії .  
                                # Перевіряємо чи поточний елемент відповідає нашим умовам , якщо так то додаємо його в список *future_вirthday_list і в кінці повертаємо його з функції.
                                # Приклад елементу списку який перевіряємо # {"name": "Andrew Gat", "birthday": datetime(2022, 1, 31).date()}
        
        вirthday_dict["birthday"] = datetime(year=current_date.year, 
                                             month=вirthday_dict["birthday"].month, 
                                             day=вirthday_dict["birthday"].day).date() # Формуємо новий елемент *datetime(year, month, day).date() 
                                                                                           # Де *year=current_date.year - значення року присвоюємо сьогоднішній рік .
                                                                                           # Параметрам *month= і *day= присвоюємо відповідні значення з поточного елементу *вirthday_dict["birthday"] . 
                                                                                           # Тобто, місяць і день залишаємо той самий, що містить пточний обєкт *datetime, який аналізуємо на дані ітерації цику.
                                                                                           # Переприсвоюємо нашому поточному елементу словнику *вirthday_dict, за ключем "birthday", нове значення  *datetime з зміненим роком на сьогоднішній.
                                                                                
                                                    # Приклад : був *{"name": "Andrew Gat", "birthday": datetime(1952, 1, 31).date()}
                                                    #           став {"name": "Andrew Gat", "birthday": datetime(2024, 1, 31).date()} # *сьогоднішній рік 2024 
                                                    # Змінений поточний елемент передаєм дальше для аналізу.
                                                    # Всі поточні елементи ,з переданого в функцію списку , в обєкті *datetime будуть містити поточний рік. 
        
        if current_date in list_data_range_from_12_26_to_01_01: # Перевіряємо чи сьогоднішня дата ,*current_date , знаходиться в списку дат *list_data_range_from_12_26_to_01_01 . # Список елементи якого - обєкти *datetime з датою діапазону з *сьогоднішній_рік.12.26 по *сьогоднішній_рік.12.31 включно .
                                                                # Якщо так, то передаєм поточний елемент на наступну перевірку. Чи його *datetime знаходиться в списку перших семи днів нового року. З *сьогоднішній_рік.01.01 по *сьогоднішній_рік.01.06 включно.

            if вirthday_dict["birthday"] in list_data_range_from_01_01_to_01_07: # Якщо *datetime поточного елементу, знаходиться в списку *list_data_range_from_01_01_to_01_07 , то такому елементу потрібно поміняти рік в *datetime на наступний від сьогоднішнього року.
               
                вirthday_dict["birthday"] = datetime(year=(current_date.year + 1), 
                                                     month=вirthday_dict["birthday"].month, 
                                                     day=вirthday_dict["birthday"].day).date() # Якщо умова вище виконалась міняємо рік на наступний від сьогоднішнього. Тобто якщо сьогоднішня дата є в діапазоні 12.26-12.31 і *datetime поточного елемента є в діапазоні 01.01-01.06
                                                     # Приклад :  *current_date = 2024-12-26
                                                     #            поточний елемент *{"name": "Andrew Gat", "birthday": datetime(2024, 1, 1).date()} # *сьогоднішній рік 2024 
                                                     #            стане {"name": "Andrew Gat", "birthday": datetime(2025, 1, 31).date()} # *наступний рік 2025 
                                                     # Тобто, якщо сьогоднішня дата є в діапазоні 12.26-12.31 і *datetime поточного елемента є в діапазоні 01.01-01.06 . Обєкт *datetime для цих елементів будуть містити наступний від поточного рік. 
                                                                                               # Змінений поточний елемент передаєм дальше для аналізу.  
             
        if (current_date + timedelta(days=7)) > вirthday_dict["birthday"] >= current_date: # Перевіряємо чи *datetime поточного елемента є в діапазоні , між сьогоднішою датою *current_date(включно) і тиждень наперед. Період визначений умовою завдання.
                                                                                           # Якщо *datetime поточного елемента попадає визначений нами діапазон - додаєм його в наш список *future_вirthday_list який будемо в кінці  повертати з функції *sort_birthdate(users)
                
                future_вirthday_list.append(вirthday_dict) # Додаєм елемент в список за допомогою методу *імя_списку.append(*елемент)
   
    return future_вirthday_list # Повертаємо з функції список який містить елменти які віповідають нашій умові завдання.
                                # Приклад : # Для сьогоднішньої дати 2024-01-08 , з нашого початкового списку який міститься в *users , # Дивись в низу коду.
                                            # перевірку пройде тільки {"name": "Ylia Voda", "birthday": datetime(1954, 1, 10).date()}
                                            # Тому дана функція поверне - [{"name": "Ylia Voda", "birthday": datetime(2024, 1, 10).date()}]


def format_birthdays(sort_birthdays): # Допоміжна функція в якій будемо, з переданого в функцію, відсортованого списку днів народжень, формувати список який буде приведений до формату згідно вимого завдання.
                                      # Формат : [{'Monday':'Bill'}, {'Wednesday': ['Kim']}]
                                      # Приймає один аргумент - список словників , повертає список словників приведених до формату [{"*День_тижня" : "Імя_працівника_деньнародження_якого_припадає__на_цей_день"}
                                      # Приклад : # приймає - [{"name": "Ylia Voda", "birthday": datetime(2024, 1, 10).date()}]
                                                  # повертає - [{'Wednesday': 'Ylia'}]  

    format_birthdays_list = []  # Пустий список в який будемо додавати відповідно відформатовані елементи передані в функцію.
    
    for birth in sort_birthdays: # Цикл в якому будемо проходитись по елементам(словникам) переданого в функцію списку.
                                 # Перевіряти чи день тижня, отриманий з обєкта *datetime поточного елемента за ключем *"birthday", є вихідним днем, тобто знаходиться в списку *WEEKEND
                                 # Якщо так , то формуємо новий словник *format_birthdays_dict де ключем буде 'Monday' , а значенням - *імя, отримане з значення за ключем "name" поточного елементу.
                                 # Якщо ні , то формуємо новий словник *format_birthdays_dict де ключем буде 'День_тижня_з_поточного_елементу' , а значенням - *імя, отримане з значення за ключем "name" поточного елементу.

        format_birthdays_dict = {} # Словник в який будемо записувати відповідні пари {ключ : значення } у в залежності від умови яка виконалась. Початкове значення пустий словник *{}
                                   # Оскільки його оголошено в середені циклу , буде порожнім на кожній ітерації циклу. 
        
        if birth["birthday"].strftime('%A') in WEEKEND: # За допомгою методу *обєкт_datetime.strftime('%A') повертаємо день тижня який припадав на поточну дану яка міститься в обєкті *datetime
                                                        # Обєкт *datetime отримуємо з поточного елменту(словник) за ключем *"birthday"
                                                        # Перевіряємо чи отримане значення з *birth["birthday"].strftime('%A') є в списку елементів *WEEKEND
                                                        # Конструкція - if *елемент in *список_елементів : # Повертає *True якщо *елемент міститься в вказаному *список_елементів . 
                                                                                                           # Повеhтає *False у всіх інших випадках

            format_birthdays_dict['Monday'] = birth["name"].split(' ')[0] # В наш словник *format_birthdays_dict за ключем 'Monday' записуємо значення імені отримані з *birth["name"].split(' ')[0]
                                                        # Де *birth["name"] - це значення з поточного словника *birth за ключем *"name" . В нашому випадку за ключем *"name" знаходиться рядок який складається з Імені пробілу і Призвища . 
                                                        # Для прикладу - birth["name"] = "Oleg Kiza" , де "name" - ключ, а "Oleg Kiza" - його значення.
                                                        # Методом *.split(' ') розбиваємо рядок "*Імя *Призвище"- за пробілом, повертаємо з рядка список і з двох елементів ["Імя", "Призвище"] де першим елементом завжди буде *Імя .
                                                        # Повертаємо з списку перший елемент за індексом *0. *Список[0] - повертає значення 0-елемента з списку, тобто перший елемент списку ,оскільки в пайтон індексація, позамовчуванню, починається з 0 .
                            # Для прикладу: # - {"name": "Roman Koval", "birthday": datetime(1954, 1, 20).date()} - День народження припаде на Суботу в цьому 2024 році.
                                            # - *format_birthdays_dict = {'Monday':'Roman'}
        else :
      
            format_birthdays_dict[birth["birthday"].strftime('%A')] = birth["name"].split(' ')[0] # Якщо умова не виконається . Тобто день народження працівника в цюму тижні не випадає на вихідні .
                                                                                                  # Тоді створюємо пару ключ пару з дня поточного елементу і відповідного імені.
                            # Для прикладу: # "Ylia Voda", "birthday": datetime(1954, 1, 10).date()} - чий день народження на цьому тижні випадає на Середу .# Сьогоднішння дата *2024-01-08
                                            # *format_birthdays_dict = {'Wednesday': 'Ylia'} 
                   
        format_birthdays_list.append(format_birthdays_dict) # Додаєм наш поточний словник *format_birthdays_dict в наш список *format_birthdays_list
                
    return format_birthdays_list # Повертаємо з функції список *format_birthdays_list який буде містити елменти словники заданого формату.
                                 # Для сьогоднішньої дати *2024-01-08 з тестового списку *users поверне *format_birthdays_list = [{'Wednesday': 'Ylia'}
  

def get_birthdays_per_week(users): # Основна функція . Отримує один аргумент - список словників формату - {"name": "Bill Gates", "birthday": datetime(1955, 10, 28).date()}
                                                     # Повертає словник формату {'Monday': ['Bill', 'Jan'], 'Wednesday': ['Kim']}
                                                     # Формат: словник з ключами дня тижня і значеннями списки імен працівників, дні народження яких припадають на цей день, в тижння.
                                                     # Дня народження, які припадають на вихідні, будуть мати ключ "Monday"  

    list_mon = []  # Пустий список в який будемо додавати імена працівників дня народження яких приападає на вихідні або понеділом на тижні. 

    list_tue = []  # Пустий список в який будемо додавати імена працівників дня народження яких приападає на вівторок на тижні.

    list_wend = [] # Пустий список в який будемо додавати імена працівників дня народження яких приападає на середу на тижні.

    list_thu = []  # Пустий список в який будемо додавати імена працівників дня народження яких приападає на четвер на тижні.

    list_fri = []  # Пустий список в який будемо додавати імена працівників дня народження яких приападає на пятинцю на тижні.

    birthdays_per_week_dict = {} # Пустий словник в який будемо додавати відповідні ключі і їх значення, згідно вимог завдання. 

    if users == []: # Якщо список пустий відразу - повертаємо пустий словник {}
        
        return {}   # Тест 1 пройдено.
        
    elif sort_birthdate(users) == []: # Cписок пустий коли всі дні народження вже минули у цьому році

        return {}   # Тест 2 пройдено.
    
    sort_birthdays = sort_birthdate(users) # За допомогою допоміжної функції *sort_birthdate(users), з переданого списку *users,
                                           # повертаємо у зміну *sort_birthdays, список з словників які відповідають умовам завдання.
                    # Для сьогоднішньої дати *2024-01-08 поверне [{"name": "Ylia Voda", "birthday": datetime(2024, 1, 10).date()}]

    list_birthdays_per_week = format_birthdays(sort_birthdays) # За допомогою допоміжної функції *format_birthdays(sort_birthdays),
                                                               # з переданого у функцію списку *sort_birthdays повертаємо списко відповідного формату.
                    # Для сьогоднішньої дати *2024-01-08 поверне в *list_birthdays_per_week = [{'Wednesday': 'Ylia'}]
    
    for user in list_birthdays_per_week: # Цикл в якому перебираємо всі елементи списку *list_birthdays_per_week які будуть словниками.
                                         # Перевіряємо ключ(містить день тижня) якому він відповідає дню і в відповідний список повертаємо значення цього ключа яке завжди буде імя працівника чий день народження випадає на цей день . 
                                         # Всі імининики, день народження яких випадає на вихідні, будуть мати ключ 'Monday' отже попадуть в список *list_mon   
        
        match list(iter(user))[0]: # За допомогою блоку match : case: - порівнюємо, повернений з поточного словника *user, ключ - '*день тижня',
                                   # і в залежності, яке чому він дорівнює , добавляємо його значення в відповідний список. 
                                   # Значення ключа буде першим елементом списку, який утворений *list() з обєкту класу *<list_iterator object at 0x0000025D161162F0> повернутого методом *iter() з поточного словника *user .
                    # Для сьогоднішньої дати *2024-01-08, поточне значення 'Wednesday'. Список [{'Wednesday': 'Ylia'}]

            case 'Monday': # Якщо поточне значення *'Monday' добавляємо значення, *імя_працівника, ключ якого *'Monday' з поточного словника, в список *list_mon 

                list_mon.append(user.get('Monday')) # Добавляємо в список *list_mon, повернуте з словника відповідне значення, *імя_працівника, отриманого методом *імя_словника.get('Monday') за ключем *'Monday'
        
            case 'Tuesday': # Якщо поточне значення *'Tuesday' добавляємо значення, *імя_працівника, ключ якого *'Tuesday' з поточного словника, в список *list_tue 
           
                list_tue.append(user.get('Tuesday')) # Добавляємо в список *list_tue, повернуте з словника відповідне значення, *імя_працівника, отриманого методом *імя_словника.get('Tuesday') за ключем *'Tuesday'
            
            case 'Wednesday': # Опис той самий що й для *case 'Monday' і *case 'Tuesday' тільки ключ *'Wednesday' список *list_wend.
           
                list_wend.append(user.get('Wednesday'))

            case 'Thursday': # Опис той самий що й для *case 'Monday' і *case 'Tuesday' тільки ключ *'Thursday' список *list_thu.
           
                list_thu.append(user.get('Thursday'))
            
            case 'Friday': # Опис той самий що й для *case 'Monday' і *case 'Tuesday' тільки ключ *'Friday' список *list_fri.
           
                list_fri.append(user.get('Friday'))
            

    if list_mon != []: # Перевіряємо чи сформований список *list_mon не пустий . 
                       # Якщо не пустий , добавляємо його в наш основний словник *birthdays_per_week_dict з ключем *'Monday'

        birthdays_per_week_dict['Monday'] = list_mon # Присвоюємо ключу *'Monday' значення списку *list_mon

    if list_tue != []: # Аналогічна перевірка , як і для списку *list_mon
        
        birthdays_per_week_dict['Tuesday'] = list_tue

    if list_wend != []: # Аналогічна перевірка , як і для списку *list_mon

        birthdays_per_week_dict['Wednesday'] = list_wend

    if list_thu != []: # Аналогічна перевірка , як і для списку *list_mon
       
        birthdays_per_week_dict['Thursday'] = list_thu 

    if list_fri != []: # Аналогічна перевірка , як і для списку *list_mon

        birthdays_per_week_dict['Friday'] = list_fri
   
    users = birthdays_per_week_dict # Сформований словник який бед містити ключем День тижня, а значенням - список імен іменинників, 
                                    # присвоюємо зміній *users, оскільки саме її потрібно повернути з функції *get_birthdays_per_week(users)
                    # Для сьогоднішньої дати *2024-01-08, поверне значення *users = {'Wednesday': ['Ylia']}
    
    return users # Цей запис був в початковому коді . Не міняв його .# Повертає з функції значення що міститься в *users


# Тестовий список для перевірки роботи програми. 
users = [
    {"name": "Andrew Gat", "birthday": datetime(2022, 1, 31).date()}, 
    {"name": "Bill Gates", "birthday": datetime(2020, 1, 7).date()},
    {"name": "Oksana Bri", "birthday": datetime(2024, 1, 29 ).date()},
    {"name": "Oleg Kiza", "birthday": datetime(2011, 1, 20).date()},
    {"name": "Dmytro Fara", "birthday": datetime(2024, 12, 28).date()},
    {"name": "Sergij Dyda", "birthday": datetime(2024, 12, 22).date()},
    {"name": "Olia Rak", "birthday": datetime(2008, 7, 31).date()},
    {"name": "Ylia Voda", "birthday": datetime(1954, 1, 10).date()},
    {"name": "Lesia Prad", "birthday": datetime(1999, 12, 31).date()},
    {"name": "Roman Koval", "birthday": datetime(2015, 1, 20).date()},
    ]  


print(get_birthdays_per_week(users)) # Принтимо результат роботи основної функці.


  